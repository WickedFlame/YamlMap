using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace YamlMap.Serialization
{
    /// <summary>
    /// Resolve <see cref="ObjectContract"/> from <see cref="Type"/>
    /// </summary>
    public class ContractResolver
    {
        /// <summary>
        /// Extract the Constructor from a <see cref="Type"/>
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public ObjectContract GetConstructor(Type type)
        {
            var ctors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                .Select(c =>
                    new
                    {
                        Constructor = c,
                        Parameters = c.GetParameters()
                    })
                .OrderBy(c => c.Parameters.Length)
                .ToList();

            if (!ctors.Any())
            {
                return new ObjectContract
                {
                    Type = type
                };
            }

            if (ctors.Any(p => p.Parameters.Length == 0))
            {
                return new ObjectContract
                {
                    Type = type,
                    Constructor = ctors.First(p => p.Parameters.Length == 0).Constructor
                };
            }

            return new ObjectContract
            {
                Type = type,
                Constructor = ctors.Last().Constructor
            };
        }

        /// <summary>
        /// Try to create the parameters for a constructor based on the items in the <see cref="IToken"/>
        /// - Parameters have to be named the sames as the properties that they are assigned to
        /// </summary>
        /// <param name="ctor"></param>
        /// <param name="tokens"></param>
        /// <returns></returns>
        public object[] CreateConstructoParameters(ConstructorInfo ctor, IToken[] tokens)
        {
            if (ctor == null)
            {
                return Array.Empty<object>();
            }

            var parameters = ctor.GetParameters();

            var parameterCollection = new List<object>();

            foreach (var parameterInfo in parameters)
            {
                if (parameterInfo.Name == null)
                {
                    continue;
                }

                var token = MatchProperty(tokens, parameterInfo.Name);

                // ensure that property will have a name from matching property or from parameterinfo
                // parameterinfo could have no name if generated by a proxy (I'm looking at you Castle)
                if (token != null && parameterInfo.Name != null)
                {
                    var converted = TypeConverter.Convert(parameterInfo.ParameterType, token.Value);
                    if (converted != null)
                    {
                        parameterCollection.Add(converted);
                    }
                }
            }

            return parameterCollection.ToArray();
        }

        private ValueToken MatchProperty(IEnumerable<IToken> tokens, string name)
        {
            // it is possible to generate a member with a null name using Reflection.Emit
            // protect against an ArgumentNullException from GetClosestMatchProperty by testing for null here
            if (name == null)
            {
                return null;
            }

            var token = tokens.Where(t => t.TokenType == TokenType.Value).FirstOrDefault(t => t.Key.Equals(name, StringComparison.OrdinalIgnoreCase)) as ValueToken;
            // must match type as well as name
            if (token == null)
            {
                return null;
            }
            
            return token;
        }
    }
}
